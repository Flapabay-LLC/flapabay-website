// This file is automatically generated. Do not edit it directly.
// import { createClient } from '@supabase/supabase-js';
// import type { Database } from './types';

// const SUPABASE_URL = "https://lsvizquyprrchbdvknjz.supabase.co";
// const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imxzdml6cXV5cHJyY2hiZHZrbmp6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI1NTczNDUsImV4cCI6MjA1ODEzMzM0NX0.p9B91BoTIbmRzCQJtfcQhaO3qQwSH5DlP_5lGccevKo";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
//   auth: {
//     persistSession: true,
//     autoRefreshToken: true,
//     storageKey: 'flapabay-auth-token',
//   }
// });

// Mock Supabase client
// import type { Database } from './types'; // This might not be needed if types are fully from authService
import type { 
    AuthService, 
    User as AuthUser, 
    Session as AuthSession, 
    AuthError, 
    UserResponse, 
    SessionResponse, 
    OAuthResponse, 
    AuthResponseBase
} from '@/services/authService'; // Adjust path as needed

// const SUPABASE_URL = "...";
// const SUPABASE_PUBLISHABLE_KEY = "...";

// Mock User and Session data structures (can be aligned further with AuthUser/AuthSession if needed)
const mockUserInternal: AuthUser = {
  id: 'mock-user-id',
  app_metadata: { provider: 'email', providers: ['email'] },
  user_metadata: { name: 'Mock User', picture: 'https://example.com/mock-avatar.png' },
  aud: 'authenticated',
  email: 'user@example.com', // Default email, will be overridden
  phone: '',
  created_at: new Date().toISOString(),
  confirmed_at: new Date().toISOString(),
  email_confirmed_at: new Date().toISOString(),
  last_sign_in_at: new Date().toISOString(),
  role: 'guest', // Default role, will be overridden
  updated_at: new Date().toISOString(),
  identities: [],
  factors: [],
  is_anonymous: false,
};

const mockSessionInternal: AuthSession = {
  access_token: 'mock-access-token',
  refresh_token: 'mock-refresh-token',
  expires_in: 3600,
  expires_at: Date.now() + 3600 * 1000,
  token_type: 'bearer',
  user: mockUserInternal,
};

let currentSession: AuthSession | null = null;
let currentUser: AuthUser | null = null;
const authStateChangeCallbacks: ((event: string, session: AuthSession | null) => void)[] = [];

const triggerAuthStateChange = (event: string, session: AuthSession | null) => {
  authStateChangeCallbacks.forEach(cb => cb(event, session));
  // Persist user for mock session restoration
  if (typeof window !== 'undefined') {
    if (event === 'SIGNED_IN' || event === 'USER_UPDATED') {
        if (session?.user) {
            secureStorage.setItem('flapabay-mock-user', JSON.stringify(session.user));
        }
    } else if (event === 'SIGNED_OUT') {
        secureStorage.removeItem('flapabay-mock-user');
    }
  }
};

// Implementation of AuthService
const mockAuthService: AuthService = {
  signInWithPassword: async (credentials) => {
    console.log('[Mock AuthService] signInWithPassword', credentials);
    let userRole: 'guest' | 'host' = 'guest'; // Default to guest

    if (credentials.email === 'user@example.com' && credentials.password === 'password123') {
      userRole = 'guest';
      currentUser = { 
        ...mockUserInternal, 
        email: credentials.email, 
        role: userRole,
        id: 'mock-guest-id',
        user_metadata: { ...mockUserInternal.user_metadata, name: 'Mock Guest User' } 
      };
    } else if (credentials.email === 'host@example.com' && credentials.password === 'password123') {
      userRole = 'host';
      currentUser = { 
        ...mockUserInternal, 
        email: credentials.email, 
        role: userRole,
        id: 'mock-host-id',
        user_metadata: { ...mockUserInternal.user_metadata, name: 'Mock Host User' } 
      };
    } else {
      triggerAuthStateChange('SIGN_IN_ERROR', null);
      return { data: { session: null }, error: { message: 'Invalid credentials' } };
    }
    
    currentSession = { ...mockSessionInternal, user: currentUser };
    triggerAuthStateChange('SIGNED_IN', currentSession);
    return { data: { session: currentSession, user: currentUser }, error: null };
  },
  signUp: async (credentials) => {
    console.log('[Mock AuthService] signUp', credentials);
    // For new sign-ups, let's default them to 'guest' role initially.
    // The role could be updated later via updateUser or a specific flow.
    const newUserRole = credentials.role || 'guest'; // Allow role to be passed during signup or default to guest

    const newUser: AuthUser = {
      ...mockUserInternal,
      id: `new-user-${Date.now()}`,
      email: credentials.email,
      phone: credentials.phone || '',
      role: newUserRole as 'guest' | 'host', // Ensure role is one of the expected types
      user_metadata: { 
        ...mockUserInternal.user_metadata, 
        name: credentials.fullName || 'New User',
        ...(credentials.user_metadata || {}) // Allow passing additional user_metadata during sign up
      },
      email_confirmed_at: new Date().toISOString(), // Auto-confirm for mock
      confirmed_at: new Date().toISOString(),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    currentUser = newUser;
    currentSession = { ...mockSessionInternal, user: currentUser }; // Auto sign-in after sign-up for mock
    triggerAuthStateChange('SIGNED_IN', currentSession);
    // USER_UPDATED might not be strictly necessary here if SIGNED_IN covers it,
    // but it depends on how onAuthStateChange consumers react.
    // Let's keep it for now if it was there before.
    triggerAuthStateChange('USER_UPDATED', currentSession); 
    return { data: { session: currentSession, user: currentUser }, error: null };
  },
  signInWithOAuth: async (options) => {
    console.log('[Mock AuthService] signInWithOAuth', options);
    // Let's assume OAuth users are guests by default for this mock
    const oauthUserRole = 'guest';
    currentUser = {
      ...mockUserInternal,
      id: 'mock-oauth-user-id',
      email: 'oauth_user@example.com',
      role: oauthUserRole,
      app_metadata: { provider: options.provider, providers: [options.provider] },
      user_metadata: { ...mockUserInternal.user_metadata, name: 'OAuth User (Guest)' },
    };
    currentSession = { ...mockSessionInternal, user: currentUser };
    triggerAuthStateChange('SIGNED_IN', currentSession);
    return { data: { session: currentSession, user: currentUser }, error: null }; 
  },
  signInWithOtp: async (otpOptions) => {
    console.log('[Mock AuthService] signInWithOtp', otpOptions);
    if (otpOptions.email) {
      console.log(`[Mock AuthService] OTP requested for email: ${otpOptions.email}`);
      currentUser = { ...mockUserInternal, email: otpOptions.email, id: `otp-email-user-${Date.now()}` };
      currentSession = { ...mockSessionInternal, user: currentUser };
      triggerAuthStateChange('SIGNED_IN', currentSession);
      return { data: { session: currentSession, user: currentUser }, error: null };
    } else if (otpOptions.phone) {
      console.log(`[Mock AuthService] OTP requested for phone: ${otpOptions.phone}`);
      return { data: { session: null }, error: null }; // Indicates OTP sent, verifyOtp step needed
    }
    return { data: { session: null }, error: { message: 'Unsupported OTP type' } };
  },
  verifyOtp: async (options) => {
    console.log('[Mock AuthService] verifyOtp', options);
    if (options.token === '123456' && options.phone) {
      currentUser = { ...mockUserInternal, phone: options.phone, id: `otp-phone-user-${Date.now()}`, phone_confirmed_at: new Date().toISOString() };
      currentSession = { ...mockSessionInternal, user: currentUser };
      triggerAuthStateChange('SIGNED_IN', currentSession);
      return { data: { session: currentSession, user: currentUser }, error: null };
    }
    if (options.token === 'magic-link-token' && options.email) { 
       currentUser = { ...mockUserInternal, email: options.email, id: `otp-email-user-${Date.now()}`, email_confirmed_at: new Date().toISOString() };
       currentSession = { ...mockSessionInternal, user: currentUser };
       triggerAuthStateChange('SIGNED_IN', currentSession);
       return { data: { session: currentSession, user: currentUser }, error: null };
    }
    triggerAuthStateChange('SIGN_IN_ERROR', null);
    return { data: { session: null }, error: { message: 'Invalid OTP' } };
  },
  signOut: async () => {
    console.log('[Mock AuthService] signOut');
    currentUser = null;
    currentSession = null;
    triggerAuthStateChange('SIGNED_OUT', null);
    return { error: null };
  },
  onAuthStateChange: (callback) => {
    console.log('[Mock AuthService] onAuthStateChange registered');
    authStateChangeCallbacks.push(callback);
    if (currentSession) {
      callback('SIGNED_IN', currentSession);
    } else {
      callback('INITIAL_SESSION', null);
    }
    return {
      unsubscribe: () => {
        console.log('[Mock AuthService] onAuthStateChange unsubscribed');
        const index = authStateChangeCallbacks.indexOf(callback);
        if (index > -1) {
          authStateChangeCallbacks.splice(index, 1);
        }
      },
    };
  },
  getUser: async () => {
    console.log('[Mock AuthService] getUser', currentUser);
    if (!currentUser && typeof window !== 'undefined') {
        const storedUser = localStorage.getItem('flapabay-mock-user');
        if (storedUser) {
            try {
                currentUser = JSON.parse(storedUser);
                // If only user is stored, session needs to be reconstructed or assumed
                currentSession = { ...mockSessionInternal, user: currentUser! }; 
                triggerAuthStateChange('SIGNED_IN', currentSession); 
            } catch (e) { console.error("Error parsing stored user for getUser", e); currentUser = null; }
        }
    }
    return { data: { user: currentUser }, error: null };
  },
  getSession: async () => {
    console.log('[Mock AuthService] getSession', currentSession);
    if (!currentSession && typeof window !== 'undefined') {
        const storedUser = localStorage.getItem('flapabay-mock-user');
        if (storedUser) {
            try {
                currentUser = JSON.parse(storedUser);
                currentSession = { ...mockSessionInternal, user: currentUser! };
                triggerAuthStateChange('SIGNED_IN', currentSession);
            } catch (e) { console.error("Error parsing stored user for getSession", e); currentSession = null; }
        }
    }
    return { data: { session: currentSession }, error: null };
  },
  updateUser: async (attributes) => {
    console.log('[Mock AuthService] updateUser', attributes);
    if (currentUser) {
      // Our AuthUser interface has `role` at the top level.
      // Supabase often keeps role in `user_metadata` or `app_metadata`.
      // Let's assume `attributes.data.role` could be a way to update it.
      
      let updatedRole = currentUser.role;
      if (attributes.data && typeof (attributes.data as any).role === 'string') {
        updatedRole = (attributes.data as any).role;
      }

      currentUser = { 
          ...currentUser, 
          user_metadata: { ...currentUser.user_metadata, ...attributes.data },
          role: updatedRole, // Apply role update if provided
          // If attributes.password is provided, a real API would handle it.
      };
      // Remove role from user_metadata if we're managing it at the top level
      if (currentUser.user_metadata.role) {
        delete currentUser.user_metadata.role;
      }

      if (currentSession) {
          currentSession = { ...currentSession, user: currentUser };
      }
      triggerAuthStateChange('USER_UPDATED', currentSession);
      return { data: { user: currentUser }, error: null };
    }
    return { data: { user: null }, error: { message: 'User not found' } };
  },
};

// Export the AuthService implementation
export { mockAuthService };

// --- Keep the mock data/storage operations separate if they are still needed --- 
// --- Or integrate them into a broader MockBackendService if that makes sense later --- 

export const mockSupabaseDataOperations = {
  from: (table: string) => ({
    select: (query?: string) => ({
      eq: (column: string, value: any) => ({
        single: async () => {
          console.log(`[Mock Data] from(${table}).select(${query || '*'}).eq(${column}, ${value}).single()`);
          if (table === 'profiles' && column === 'id') {
            if(currentUser && value === currentUser.id) {
              return { 
                data: { 
                  id: currentUser.id, 
                  full_name: currentUser.user_metadata.name, 
                  avatar_url: currentUser.user_metadata.picture, 
                  // Ensure the role from the currentUser is returned here
                  role: currentUser.role || 'guest' // Default to 'guest' if somehow undefined
                }, 
                error: null 
              };
            }
          }
          return { data: null, error: { message: 'Mock data not found' } };
        },
      }),
      filter: (column: string, operator: string, value: any) => ({
        async then(onFulfilled?: (result: { data: any[] | null, error: any }) => any, _onRejected?: (reason: any) => any) {
            console.log(`[Mock Data] from(${table}).select(${query || '*'}).filter(${column}, ${operator}, ${value})`);
            if (onFulfilled) {
                if (table === 'some_table_name') {
                    return onFulfilled({ data: [{id: 1, name: 'mock item 1'}, {id: 2, name: 'mock item 2'}], error: null });
                }
                return onFulfilled({ data: [], error: null });
            }
        }
      }),
      async then(onFulfilled?: (result: { data: any[] | null, error: any }) => any, _onRejected?: (reason: any) => any) {
        console.log(`[Mock Data] from(${table}).select(${query || '*'})`);
        if (onFulfilled) {
            if (table === 'profiles') { 
                if (currentUser) {
                    return onFulfilled({ data: [{ id: currentUser.id, full_name: currentUser.user_metadata.name, avatar_url: currentUser.user_metadata.picture, role: currentUser.role || 'guest' }], error: null });
                }
            }
            return onFulfilled({ data: [], error: null });
        }
      }
    }),
    insert: async (data: any) => {
      console.log(`[Mock Data] from(${table}).insert()`, data);
      const newRecord = Array.isArray(data) ? data.map(d => ({ ...d, id: Date.now().toString() })) : { ...data, id: Date.now().toString() };
      return { data: newRecord, error: null };
    },
    update: (data: any) => ({
      eq: async (column: string, value: any) => {
        console.log(`[Mock Data] from(${table}).update().eq(${column}, ${value})`, data);
        return { data: [data], error: null }; 
      },
      match: async (query: any) => {
        console.log(`[Mock Data] from(${table}).update().match()`, data, query);
        return {data: [data], error: null };
      }
    }),
    delete: () => ({
      eq: async (column: string, value: any) => {
        console.log(`[Mock Data] from(${table}).delete().eq(${column}, ${value})`);
        return { data: [{id: value}], error: null };
      },
      match: async (query: any) => {
        console.log(`[Mock Data] from(${table}).delete().match()`, query);
        return {data: [query], error: null };
      }
    }),
  }),
  storage: {
    from: (bucketId: string) => ({
      upload: async (path: string, file: File, _options?: any) => {
        console.log(`[Mock Storage] from(${bucketId}).upload(${path})`, file);
        return { data: { path: `${bucketId}/${path}` }, error: null };
      },
      download: async (path: string) => {
        console.log(`[Mock Storage] from(${bucketId}).download(${path})`);
        const mockFileContent = 'this is mock file content';
        const blob = new Blob([mockFileContent], { type: 'text/plain' });
        return { data: blob, error: null };
      },
      getPublicUrl: (path: string) => {
        console.log(`[Mock Storage] from(${bucketId}).getPublicUrl(${path})`);
        return { data: { publicUrl: `https://example.com/mock-storage/${bucketId}/${path}` } };
      },
    }),
  },
};

// Initial load of mock user from localStorage
if (typeof window !== 'undefined') {
    const storedUser = localStorage.getItem('flapabay-mock-user');
    if (storedUser) {
        try {
            currentUser = JSON.parse(storedUser) as AuthUser;
            currentSession = { ...mockSessionInternal, user: currentUser! };
        } catch (e) {
            console.error("Failed to parse stored mock user during initial load", e);
            secureStorage.removeItem('flapabay-mock-user');
            currentUser = null;
            currentSession = null;
        }
    }
}
